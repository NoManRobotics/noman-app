{
    "English": {
        "robot_profile": "Robot Profile",
        "type": "Type:",
        "name": "Name:",
        "joint_info": "Arm Information",
        "controller": "Controller",
        "simulator": "Simulator",
        "firmware": "Firmware",
        "help": "Help",
        "language": "Language",
        "serial_connection": "Serial Connection",
        "arm_control": "Arm Control",
        "potentiometers_enabled": "Mini Controller",
        "potentiometers_disabled": "Serial Control  ",
        "select_port": "Select Port",
        "status": "Status",
        "callback": "Callback",
        "serial": "Serial",
        "connect": "Connect",
        "disconnect": "Disconnect",
        "connected": "connected",
        "disconnected": "Disconnected",
        "tool": "Tool",
        "loop_delay": "Delay (sec)",
        "execute": "Execute",
        "record_once": "Record Once",
        "program": "Program",
        "start_recording": "Start Recording",
        "stop_recording": "Stop Recording",
        "recording": "Recording...",
        "stopped_recording": "Stopped recording",
        "replay_trajectory": "Replay Trajectory",
        "repeat": "Repeat",
        "stop": "STOP",
        "save": "Save",
        "load": "Load",
        "resume": "RESUME",
        "setting": "Setting",
        "idle": "Idle",
        "home": "Home",
        "calibrate_home": "Calibrate Home",
        "signal_analyzer": "Signal Analyzer",
        "generater": "Script Generator",
        "reset": "Reset",
        "generate_script": "Generate Script",
        "board_caution": "currently only PWM and servo library are supported for servo motors. Other custom boards need to be tested for feasibility.",
        "joint_pins": "Joint Pins",
        "gripper_pin": "Gripper Pin",
        "generate": "Generate",
        "motor_count": "Joint Num",
        "enter_start_positions": "Enter start positions for each servo:",
        "min": "Min",
        "max": "Max",
        "angle_range": "Angle Range",
        "board": "Development Board",
        "update_firmware": "Update Firmware",
        "parameters": "Parameters",
        "arduino_model": "Arduino Model",
        "arduino_parameters": "Parameters",
        "baud_rate": "Baud Rate",
        "flash_mode": "Flash Mode",
        "flash_frequency": "Flash Frequency",
        "confirm": "Confirm",
        "update_custom_firmware": "Update Custom Firmware",
        "no_ports_available": "No ports available",
        "success": "Success",
        "update_success": "Firmware update successful",
        "failed_fetch_firmware": "Firmware fetch failed",
        "error": "Error",
        "unknown_error": "An unknown error occurred",
        "ros": "ROS",
        "switch_to_ros": "Switch to ROS",
        "setup_ros_description": "Our robot was initially developed on Ubuntu 20.04 LTS, ROS Noetic. You can find the quick-install guide from the link below.\n\nWe recommend developing under the noetic version (Ubuntu 20.04 LTS) for the most complete support.",
        "urdf_description": "Universal Robot Description Format (URDF) is the description of the robot's physical structure.\n\n1. Download the URDF file from the link\n2. Unzip the downloaded file\n3. Place the unzipped files under the /src directory of your workspace\n\nNote: ROS1 and ROS2 URDF formats are different and cannot be used interchangeably!",
        "on": "ON",
        "off": "OFF",
        "ros_frame": "ROS Frame",
        "received_message": "Received Message:",
        "ros_preparation": "Preparation before enabling ROS",
        "enable_ros": "Enable ROS",
        "disable_ros": "Disable ROS",
        "enable_ros2": "Enable ROS2",
        "disable_ros2": "Disable ROS2",
        "system_check": "System Check",
        "ros_linux_only": "ROS is only available on Linux systems.",
        "system_not_linux": "System is not Linux",
        "checking_system": "Checking system...",
        "linux_version": "Linux version",
        "ros_version": "ROS version",
        "error_checking_ros": "Error checking ROS version",
        "ros2_preparation": "Preparation before enabling ROS2",
        "ros2_not_found": "ROS2 installation not found",
        "ros2_version": "ROS2 Version",
        "step_1": "Step 1: Download URDF Description",
        "step_2": "Step 2: Configure ROS",
        "step_3": "Step 3: Create ROS Workspace",
        "step_4": "Step 4: Configure MoveIt",
        "step_5": "Step 5: Set Dependencies and System Permissions",
        "step_6": "Step 6: Test Rviz Control",
        "step_complete": "I have completed this step",
        "workspace_path": "Workspace Path",
        "workspace_description_ros1": "Select the workspace path and create the ROS workspace. This will create the necessary directory structure and set the environment variables. The build command for ROS is as follows.",
        "workspace_description_ros2": "Select the workspace path and create the ROS2 workspace. This will create the necessary directory structure and set the environment variables. The build command for ROS2 is as follows.",
        "deps_description_ros1": "Before connecting robot arm by Rosserial, you need to give permission to the serial port. The default serial port is /dev/ttyUSB0. You can confirm the correct port number through the following command and give permission to the corresponding device.",
        "deps_description_ros2": "ROS2 needs to install micro-ROS for serial communication. Run the following commands to configure micro-ROS and give permission to the serial port.",
        "create_workspace": "Create Workspace",
        "workspace_created": "Workspace created successfully",
        "workspace_creation_error": "Error creating workspace",
        "setup_ros2_description": "ROS2 supports Ubuntu and Windows systems. Please select the installation method suitable for your system. It is recommended to use Ubuntu 22.04 LTS because the package dependencies are more stable for ROS Humble and above.\n\nThe installation on Windows refers to external resources.",
        "installation": "Installation",
        "ros2_workspace_description": "Select the ROS2 workspace path and create the ROS2 workspace. This will create the necessary directory structure and set the environment variables.",
        "moveit_description_ros1": "Use MoveIt Setup Assistant to configure the robot's motion planning groups. \nPlease run the following command to start the configuration assistant.",
        "moveit_description_ros2": "Use MoveIt2 Setup Assistant to configure the robot's motion planning groups.\n\nPlease run the following command to start the configuration assistant.\n\nYou must use ROS Humble and above because MSE is only supported for Ubuntu >=20.04 LTS.",
        "copy": "Copy",
        "copied_to_clipboard": "Copied to clipboard",
        "view_tutorial": "View configuration tutorial",
        "final_step_description": "You now have a ready ROS environment to control the robot arm. You can enable ROS mode for the robot arm and test your robot using RVIZ. Here are the commonly used commands:",
        "serial_disconnect_warning": "Disconnect serial port in controller to update.",
        "save_urdf_zip": "Save URDF ZIP",
        "urdf_saved": "URDF ZIP file saved successfully",
        "urdf_save_error": "Error saving URDF ZIP file",
        "urdf_load_error": "Error loading URDF file",
        "update_failed": "Update failed",
        "setup_ros": "Configure ROS",
        "kinematics": "Kinematics",
        "urdf_file": "URDF File:",
        "browse": "Browse",
        "simulation": "Simulation",
        "forward_kinematics": "Forward Kinematics",
        "inverse_kinematics": "Inverse Kinematics",
        "calculate_end_position": "Calculate End Position",
        "calculate_joint_angles": "Calculate Joint Angles",
        "send_to_robot": "Send",
        "joint": "Joint",
        "end_position": "End Position",
        "fk_result": "FK Result",
        "ik_result": "IK Result",
        "forward_kinematics_result": "Forward Kinematics Result",
        "input_joint_angles": "Input Joint Angles",
        "end_effector_position": "End Effector Position",
        "end_effector_orientation": "End Effector Orientation",
        "inverse_kinematics_complete": "Inverse Kinematics Calculation Complete",
        "target_position": "Target Position",
        "actual_position": "Actual Position",
        "position_error": "Position Error",
        "calculated_joint_angles": "Calculated Joint Angles",
        "urdf_loaded_successfully": "URDF file loaded successfully",
        "failed_to_load_urdf": "Failed to load URDF file",
        "solver": "Solver",
        "planner": "Planner",
        "solver_init": "Solver Initialisation",
        "lm_lambda": "Lambda (λ)",
        "lm_epsilon": "Epsilon (ε)",
        "max_iterations": "Max Iterations",
        "dls_damping": "Damping Factor",
        "dls_epsilon": "Epsilon (ε)",
        "sqp_mu": "Mu (μ)",
        "sqp_epsilon": "Epsilon (ε)",
        "trac_ik_epsilon": "Epsilon (ε)",
        "self_collision_check": "Self Collision Check",
        "pathpoints": "Path Points",
        "urdf_file_not_found": "URDF file not found",
        "tab_general": "General",
        "tab_controller": "Controller",
        "tab_kinematics": "Kinematics",
        "tab_vision": "Vision",
        "general_help": "## What is the software used for?\n\nConnecting real robot arms through the protocol interface, the software can control, plan and simulate multi-purpose tasks for different robot profiles.\n\n## Supported Protocol:\n\n1. Serial protocol for UART communication. \n\n2. CAN protocol for closed-loop motor control (under development)\n\n3. User defined protocol for their own need.\n\n## Requirements of robot support:\n\n1. MINIMA or Robot arms with URDF/Xacro/Mujoco;\n\n2.Robot arms with Degree of Freedom less than 7.\n\n## Functional features:\n\n1. Robot Profile: description of robot arm as planning groups.\n\n2. Control: joint limits, joint space motion and speed.\n\n3. Planning: Motion planning of groups with kinematics, collision avoidance, trajectory optimisation.\n\n4. Simulation: Interaction of robot motion and enviroment, under visual shapes, geometric collision and custom shapes.\n\n5. ROS support: ROS1 and ROS2 setup service including system setup, ros quick setup, rviz and communication.\n\n6. Calibration: initial joint angle calibration for PWM and micro steps.\n\n7. Trajectory Optimisation: linear, trapezoidal, s-curve, polynomial(joint space) and b-spline and blend interpolation(cartesian space), with speed, accelation, jerk and joint limit constraints.\n\n8. Robot Programming langauge: Point-to-Point, Linear move, Circular Move, Home, Delay and Tool change.\n\n9. Vision Application: Eye-in-Hand and Eye-to-Hand calibration,  template matching and object detection.\n\n10. Workspace analysis: Reachable area without self-collision.\n\n11. Firmware update: Firmware update from remote for MINIMA.\n\n12. LLM agent for robot-related Q&A and basic software manipulation.",
        "controller_help": "## Usage: \nAfter establishing a serial connection through robot profile frame, you can control robot arm in joint space through the sliders and calibrate the robot arm to correct home position.\n\nKey features:\n\n1. Speed control for robot motion.\n\n2. Reply recorded robot trajectories with features of pause and reply counts.\n\n3. Give user access to all protocol commands with detailed mannual.\n\n## Additions:\n\n1. Custom script generation to support the protocol commands.\n\n2. A switch option to control the robot arm through mini controller powered by potentiometers, for teleoperation purpose (no official kits and need user to assemble it)",
        "kinematics_help": "## Terminology\n\n## Forward Kinematics\n\nForward kinematics is used to calculate the position and orientation of the robot arm's end effector.\n\n**Usage:**\n- Adjust joint angle sliders to desired positions\n\n## Inverse Kinematics\n\nInverse kinematics is used to calculate angles in joint space to reach the specified end effector/flange pose.\n\n## Jacobian\n\nJacobian is a matrix that relates the velocities of a robot's joints to the velocities of its end-effector (the robot's hand or tool). It is used in iterative methods to find the joint angles needed to reach a desired end-effector pose, by calculating the required joint velocities to move the end-effector in a specific direction.\n\n** Solver Options:**\n1. Levenberg-Marquardt Solver\n\n2. Damped Least Square Solver\n\n3. TRAC-IK Solver\n\n## Planner groups\n\nThe support planners are Direct, RRT and CHOMP. The design of planner is to generate reasonable path containing a list of waypoints, and to avoid colisions on the path at the same time.\n\n## Task Board:\n\n The task board is for users who want to do automated tasks by defining determediate waypoints, for example non-stopping tasks in Palletizing. We support exporting and loading tasks, and we are planning to add support to convert the tasks to gcode.",
        "vision_help": "## Vision Guidance\n\n## Adding Cameras\n**1.** Click the plus button on the right to add cameras, maximum of two cameras.\n**2.** Camera resolution can be selected, recommend no more than 1080p, as higher resolution affects detection speed.\n\n## Calibration\nBefore calibration, you need to select an Aruco calibration board, choose the appropriate calibration board format and print it.\n\nSpecific steps:\n**1.** Calibration board selection.\n**2.** Hand-eye calibration: Choose eye-in-hand or eye-to-hand, for eye-to-hand, additional calibration board offset setting is required. Calibration requires at least 9 samples, each time please adjust robot arm pose through Kinematics page and send, then capture current calibration board pose. Finally click to perform calibration.\n**3.** Results: Please check the transform matrix in the results section, and verify camera position correctness through 3d plot, select the calibration method that best matches the results with reality. Please save the results locally.\n\n## Detection\nBefore detection, localization is required, by moving end effector to camera center position, check camera to world coordinate system error, you can compensate error through fine adjustment.\n**1.** Color detection: Users can select colors from current frame, or define through color palette, and start object detection.\n**2.** Template detection: First crop current frame to select template. Fast Fourier Transform template detection can achieve scale and rotation invariance, you can change current view to correlation to see FFT domain image format. However, FFT detection is sensitive to image size and deformation, so please use smaller resolution to ensure detection speed and accuracy.",
        "firmware_help": "## Firmware Update Process:\n\n1. Connect the robot arm to your computer via USB.\n2. follow the on-screen instructions, and press 'Update Firmware' or 'Update Custom Firmware' button.\n3. Do not disconnect the arm or close the app during the update process.\n\n## Frequently Asked Questions:\n\n1. Q: How long does a firmware update usually take?\nA: A typical update takes 10 seconds, depending on your internet speed and the size of the firmware. Since our remote is hosted on GitHub, it is recommended to connect with VPN.\n\n2. Q: What should I do if the firmware update fails?\nA: Ensure a stable USB connection, check that the controller board LED is on, and verify that you can connect to Github.\n\n3. Q: How often are new firmware versions released?\nA: Updates are released as needed for bug fixes and new features.\n\n4. Q: Is it necessary to update the firmware regularly?\nA: While not always necessary, we recommend keeping your firmware up to date to ensure optimal performance and access to the latest features.",
        "app_information": "App Information",
        "contact_us": "Contact Us",
        "website": "Website",
        "email": "Email",
        "item": "Item",
        "value": "Value",
        "version": "Version",
        "release_date": "Release Date",
        "developer": "Developer",
        "dependencies": "Dependencies",
        "platforms": "Platforms",
        "copyright_text": "NoMan Robotics All Rights Reserved",
        "board_type": "Board Type:   ESP32/Arduino",
        "library_type": "Library:",
        "command_info_title": "Control Commands Lookup",
        "basic_control": "Basic Control",
        "trajectory_recording": "Trajectory Recording",
        "trajectory_playback": "Trajectory Playback",
        "control_mode": "Control Mode",
        "data_format": "Data Format",
        "joint_angle_array": "Joint Angle Array",
        "delay_time_desc": "Entry Input\n- delay_time: Action execution delay (ms)",
        "record_feedback": "Record Feedback",
        "min_pulse": "MIN PULSE WIDTH",
        "max_pulse": "MAX PULSE WIDTH",
        "frequency": "FREQUENCY",
        "majordomo": "Majordomo",
        "device": "Device",
        "send": "Send",
        "apply": "Apply",
        "select_model": "Select Model:",
        "input_placeholder": "Enter text here...",
        "speed": "Speed:",
        "firmware_update": "Firmware Update",
        "upload": "Flashing Firmware",
        "fetch_remote": "Fetch Remote",
        "select_firmware": "Select Firmware:",
        "settings": "Settings",
        "actuator_selection": "Tool:", 
        "check_version": "Check Version",
        "load_json_file": "Load JSON File",
        "joint_angle_analysis": "Joint Angle Analysis",
        "time": "Time",
        "angle": "Angle",
        "file_load_error": "File Load Error",
        "tool_change_error": "Tool change error",
        "robot_status": "Robot Base",
        "end_effector_offset": "End Effector Offset",
        "position": "XYZ(mm):",
        "orientation": "RPY(deg):",
        "scale_factor": "Scale Factor:",
        "fixed_object": "Fixed Object (No Physics Effect)",
        "load_model": "Load Model",
        "shape_type": "Shape Type:",
        "length": "Length:",
        "width": "Width:",
        "height": "Height:",
        "radius": "Radius:",
        "size": "Size:",
        "color": "Color:",
        "alpha": "Alpha:",
        "create": "Create",
        "set_base_pose": "Set Base Pose",
        "set_end_position": "Set End Position",
        "start_simulation": "Start Simulation",
        "stop_simulation": "Stop Simulation",
        "save_world": "Save World",
        "load_world": "Load World",
        "load_shapes": "Load Shapes",
        "collision_shapes": "Collision Shapes",
        "visual_shapes": "Visual Shapes",
        "network_diagnosis": "Network Diagnosis",
        "remote": "Remote",
        "check": "Check",
        "calibration": "Calibration",
        "detection": "Detection",
        "add_camera": "Add Camera",
        "calibration_board": "Calibration Board",
        "pose_sampling": "Pose Sampling",
        "result": "Result",
        "localisation": "Localisation",
        "detector": "Detector",
        "interaction": "Interaction",
        "control_with_vision": "Vision Application",
        "robot_control_language": "Robot Control Language",
        "workspace_analyzer": "Workspace Analyzer",
        "coordinate_system": "Frame:",
        "joint_ranges": "Joint Ranges",
        "analysis_settings": "Analysis Settings",
        "sampling_resolution": "Sampling Resolution:",
        "alpha_value": "Alpha Value:",
        "analyze_workspace": "Analyze Workspace",
        "ready_to_analyze": "Ready to analyze...",
        "analysis_results": "Analysis Results",
        "workspace_volume": "Workspace Volume:",
        "reachable_density": "Reachable Density:",
        "gcode_controller": "G-code Controller",
        "rcl_editor": "RCL Editor",
        "commands": "Commands",
        "lookup": "CMD Lookup",
        "load_gcode": "Load G-code",
        "save_gcode": "Save G-code",
        "text2gcode": "Text2GCode",
        "work_range": "Work Range",
        "preview": "Preview",
        "compile": "Compile",
        "simulate": "Simulate",
        "status_ready": "Status: Ready",
        "status_paused": "Status: Paused",
        "status_running": "Status: Running",
        "status_stopped": "Status: Stopped",
        "status_complete": "Status: Complete",
        "line_counter": "Line",
        "clear_terminal": "Clear Terminal",
        "gcode_lookup": "## Command Lookup Table\n────────────────────────────────────\n\n## Basic Syntax:\n- One command per line\n- Add comments after semicolon (;)\n- Coordinate unit: meters (m), Angle unit: degrees (°)\n\n## Shortcuts:\n- Ctrl+F: Auto-fill parameters from current robot state\n\n## Sections:\n@@-- header@@ Script start section (optional)\n@@-- main@@ Main program section\n@@-- footer@@ Script end section\n\n## Explanation:\n- In the following code, < > contains value content, [ ] contains optional content\n\n────────────────────────────────────\n\n## $$HOME$$ - Return to Origin\nMove the robot to the predefined zero position\nSyntax: $$HOME$$;\n\n────────────────────────────────────\n\n## $$PTP$$ - Point to Point Motion\nMove the end effector to the specified Cartesian coordinate position with the shortest joint path\nSyntax: $$PTP$$ X=<x> Y=<y> Z=<z> [A=<a>] [B=<b>] [C=<c>];\nParameters: X,Y,Z are position coordinates (meters), A,B,C are rotation angles (degrees)\n- Ctrl+F: Auto-fill current target position and orientation\n\n────────────────────────────────────\n\n## $$JTJ$$ - Joint Space Motion\nMove selected joints to specified joint positions with the shortest joint path\nSyntax: $$JTJ$$ J1=<angle1> [J2=<angle2>] [J3=<angle3>] [J4=<angle4>] [J5=<angle5>] [J6=<angle6>] [J7=<angle7>] [vel{J1:<speed>%, J2:<speed>%, ...}];\nParameters: J1,J2,J3,J4,J5,J6,J7 are optional joint parameters (degrees), vel{} is optional speed limit (percentage)\n- Ctrl+F: Auto-fill current joint angles\n\n────────────────────────────────────\n\n## $$LIN$$ - Linear Motion\nMove the end effector along a straight path to the specified position\nSyntax: $$LIN$$ X=<x> Y=<y> Z=<z> [A=<a>] [B=<b>] [C=<c>];\nParameters: X,Y,Z are position coordinates (meters), A,B,C are rotation angles (degrees)\n- Ctrl+F: Auto-fill current target position and orientation\n\n────────────────────────────────────\n\n## $$CIRC$$ - Circular Motion\nGiven start point, end point and auxiliary point on the arc, move along the arc path to the target position\nSyntax: $$CIRC$$ X=<x> Y=<y> Z=<z> I=<i> J=<j> K=<k> [A=<a>] [B=<b>] [C=<c>];\nParameters: X,Y,Z are target position (meters), I,J,K are auxiliary point offset (meters), A,B,C are rotation angles (degrees)\n- Ctrl+F: Auto-fill current target position and orientation, I=0 J=0 K=0\n\n────────────────────────────────────\n\n## $$VEL$$ - Velocity Setting\nSet velocity limits for each joint\nSyntax: $$VEL$$ J1=<speed>% [J2=<speed>%] [J3=<speed>%] [J4=<speed>%] [J5=<speed>%] [J6=<speed>%] [J7=<speed>%];\nParameters: J1,J2,J3,J4,J5,J6,J7 are optional joint speed parameters (1-200%)\n\n────────────────────────────────────\n\n## $$DELAY$$ - Delay\nInsert a pause in the program\nSyntax: $$DELAY$$ MS=<milliseconds>; or $$DELAY$$ S=<seconds>;\nParameters: MS is milliseconds, S is seconds\n\n────────────────────────────────────\n\n## $$TOOL$$ - Tool Change\nSwitch end effector/tool state\nSyntax: $$TOOL$$[<tool_name>] [IO<IO1>] [IO<IO2>];\nParameters: tool_name, IO1, IO2 are tool IO ports (optional)\nNote: MINIMA supports GRIPPER, PEN_HOLDER, VACUUM_PUMP, other tools need customization\n\n────────────────────────────────────\n\n## $$M280$$ - Gripper Control\nControl gripper state (open/close)\nSyntax: $$M280$$ state=<state_value>;\nParameters: state_value is gripper state (0=open, 1=close)\nExample: $$M280$$ state=1; (close gripper)",
        "ui_settings": "UI Settings",
        "robot_settings": "Robot Settings", 
        "advanced_settings": "Advanced Settings",
        "language_settings": "Language Settings",
        "interface_language": "Interface Language:",
        "display_parameters": "Display Parameters",
        "calibration_settings": "Calibration Settings",
        "speed_settings": "Speed Settings",
        "protocol_settings": "Protocol Settings",
        "trajectory_optimiser": "Trajectory Optimiser",
        "interpolation_settings": "Interpolation Settings",
        "ready": "Ready",
        "position_steps_kinematics": "Position Steps (Kinematics)",
        "orientation_steps_kinematics": "Orientation Steps (Kinematics)",
        "preview_point_radius": "Preview Point Radius (RCL)",
        "preview_axis_length": "Preview Axis Length (RCL)",
        "serial_baud_rate": "Serial Baud Rate",
        "can_bitrate": "CAN Bitrate",
        "time_step_dt": "Time Step (dt)",
        "max_acceleration": "Max Acceleration", 
        "max_jerk": "Max Jerk",
        "acceleration": "Acceleration",
        "jerk": "Jerk",
        "trajectory_method": "Trajectory Method",
        "interpolation_method": "Interpolation Method",
        "degrees": "degrees",
        "tooltip_display_params": "Control display and interface parameters for position steps, orientation steps, and preview visualization settings.",
        "tooltip_calibration": "Calibrate each joint independently.\nWhen a joint hits physical limits before reaching the actual joint limits, consider reducing the range.\nWhen joints are not at the correct home position, the max/min pulse widths for servo motors are shifted.",
        "tooltip_speed": "Control the speed scale of individual joints.",
        "tooltip_protocol": "Configure serial port baud rate and CAN bus bitrate for robot communication protocols.",
        "tooltip_trajectory": "Control the trajectory optimizer parameters. Restart the application to apply the changes.",
        "tooltip_interpolation": "Control the interpolation method for path planning.\n\nLinear: Linear interpolation\nSpline: Cubic B-spline interpolation\nBlend: Bezier interpolation",
        "file_type": "File Type:",
        "file_path": "File Path:",
        "tooltip_hand_eye_calibration": "Hand-eye calibration captures at least 9 samples for accurate results.\nRobot poses need significant differences to obtain different viewpoints.\nCalibration board pattern should be completely visible within camera field of view.",
        "license": "License",
        "license_status": "License Status",
        "software_activation": "Software Activation",
        "activation_code": "Activation Code",
        "activate": "Activate",
        "activating": "Activating...",
        "plan_description": "Free plan:\n- use the software with only MINIMA related profiles.\n\nLicensed Plan:\n- add up to 5 maximum profile in addition to MINIMA profiles.",
        "license_type": "License Type:",
        "expiry_date": "Expiry Date:",
        "days_before_expiry": "Days Before Expiry:",
        "maximum_devices": "Maximum Devices:",
        "unlimited": "Unlimited",
        "expired": "Expired",
        "days": "days"
    },
    "中文": {
        "robot_profile": "机器人配置",
        "type": "类别:     ",
        "name": "名称:     ",
        "joint_info": "机械臂情报",
        "controller": "控制器",
        "firmware": "固件",
        "simulator": "模拟器",
        "help": "帮助",
        "language": "语言",
        "serial_connection": "串行连接",
        "arm_control": "手臂控制",
        "potentiometers_enabled": "小型控制器      ",
        "potentiometers_disabled": "串口控制器      ",
        "select_port": "选择端口",
        "tool": "工具",
        "loop_delay": "延迟（秒）",
        "execute": "执行",
        "record_once": "记录一次",
        "program": "程序",
        "start_recording": "开始录制",
        "stop_recording": "停止录制",
        "recording": "正在录制...",
        "stopped_recording": "已停止录制",
        "replay_trajectory": "重播轨迹",
        "repeat": "重复",
        "stop": "停止",
        "save": "保存",
        "load": "加载",
        "resume": "恢复",
        "setting": "设置",
        "idle": "空闲",
        "status": "状态",
        "callback": "回调",
        "serial": "串口",
        "connect": "连接",
        "disconnect": "断开连接",
        "connected": "已连接",
        "disconnected": "已断开连接",
        "signal_analyzer": "信号分析器",
        "generater": "脚本生成器",
        "home": "归零",
        "calibrate_home": "校准归零",
        "board": "开发板",
        "update_firmware": "更新固件",
        "confirm": "确认",
        "generate_script": "生成脚本",
        "board_caution": "目前仅支持PWM和伺服库对伺服电机进行控制。其他自定义主板需自行测试可行性。",
        "joint_pins": "关节引脚",
        "gripper_pin": "夹持器引脚",
        "reset": "重置",
        "motor_count": "电机数量",
        "enter_start_positions": "输入每个伺服电机的起始位置:",
        "min": "最小",
        "max": "最大",
        "angle_range": "角度范围",
        "parameters": "参数",
        "arduino_parameters": "参数",
        "arduino_model": "Arduino 型号",
        "baud_rate": "波特率",
        "flash_mode": "闪存模式",
        "flash_frequency": "闪存频率",
        "on": "开",
        "off": "关",
        "setup_ros_description": "我们的机器人最初在Ubuntu 20.04 LTS, ROS Noetic 上开发。您可以通过以下链接获取一键安装ROS环境的脚本。\n\n我们推荐在noetic版本(Ubuntu 20.04 LTS)下进行开发以获得最完备支持。",
        "urdf_description": "通用机器人描述格式(URDF)是机器人的物理结构描述。\n\n1. 从链接下载URDF文件\n2. 解压下载的文件\n3. 将解压后的文件放置在workspace的/src目录下\n\n注意:ROS1和ROS2的URDF格式有很大区别,无法通用！",
        "received_message": "接收到的消息:",
        "generate": "生成",
        "ros_frame": "ROS 框架",
        "ros": "ROS",
        "switch_to_ros": "切换到 ROS",
        "ros_preparation": "启用 ROS 前的准备工作",
        "enable_ros": "启用ROS",
        "disable_ros": "禁用 ROS",
        "enable_ros2": "启用ROS2",
        "disable_ros2": "禁用ROS2",
        "ros_linux_only": "ROS 仅在 Linux 系统上可用。",
        "serial_disconnect_warning": "断开控制器串口连接以进行更新",
        "save_urdf_zip": "保存URDF ZIP文件",
        "urdf_saved": "URDF ZIP文件保存成功",
        "urdf_save_error": "保存URDF ZIP文件时出错",
        "urdf_load_error": "加载URDF文件时出错",
        "update_failed": "更新失败",
        "setup_ros": "配置ROS",
        "kinematics": "运动学",
        "urdf_file": "URDF文件:",
        "browse": "浏览",
        "simulation": "仿真模拟",
        "forward_kinematics": "正向运动学",
        "inverse_kinematics": "逆向运动学",
        "calculate_end_position": "计算末端位置",
        "calculate_joint_angles": "计算关节角度值",
        "send_to_robot": "发送",
        "joint": "关节",
        "end_position": "末端位置",
        "fk_result": "正向运动学结果",
        "ik_result": "逆向运动学结果",
        "forward_kinematics_result": "正向运动学计算结果",
        "input_joint_angles": "输入关节角度",
        "end_effector_position": "末端执行器位置",
        "end_effector_orientation": "末端执行器姿态",
        "inverse_kinematics_complete": "逆运动学计算完成",
        "target_position": "目标位置",
        "actual_position": "实际位置",
        "position_error": "位置误差",
        "calculated_joint_angles": "计算得到的关节角度",
        "urdf_loaded_successfully": "URDF文件加载成功",
        "failed_to_load_urdf": "加载URDF文件失败",
        "solver": "求解器",
        "planner": "路径规划器",
        "solver_init": "求解器初始化",
        "lm_lambda": "Lambda (λ)",
        "lm_epsilon": "收敛阈值 (ε)",
        "max_iterations": "最大迭代次数",
        "dls_damping": "阻尼因子",
        "dls_epsilon": "收敛阈值 (ε)",
        "sqp_mu": "Mu (μ)",
        "sqp_epsilon": "收敛阈值 (ε)",
        "trac_ik_epsilon": "收敛阈值 (ε)",
        "self_collision_check": "自碰撞检测",
        "pathpoints": "路径点      ",
        "system_check": "系统检查",
        "urdf_file_not_found": "未找到URDF文件",
        "system_not_linux": "系统不是Linux",
        "checking_system": "正在检查系统...",
        "linux_version": "Linux版本",
        "ros_version": "ROS版本",
        "error_checking_ros": "检查ROS版本时出错",
        "ros2_preparation": "启用 ROS 前的准备工作",
        "ros2_not_found": "未找到ROS2安装",
        "ros2_version": "ROS2版本",
        "step_1": "步骤 1:下载URDF描述文件",
        "step_2": "步骤 2:设置ROS环境",
        "step_3": "步骤 3:创建ROS工作空间",
        "step_4": "步骤 4:配置MoveIt",
        "step_5": "步骤 5:设置依赖项和系统权限",
        "step_6": "步骤 6:测试Rviz控制",
        "step_complete": "我已完成此步骤",
        "workspace_path": "工作空间路径",
        "workspace_description_ros1": "选择工作空间路径并创建ROS工作空间。这将创建必要的目录结构并设置环境变量。ROS中的构建命令为以下指令。",
        "workspace_description_ros2": "选择工作空间路径并创建ROS2工作空间。这将创建必要的目录结构并设置环境变量。ROS2中的构建命令为以下指令。",
        "deps_description_ros1": "Rosserial连接串口前需要给予串口权限,默认的串口为/dev/ttyUSB0,您也可以通过以下指令查看和确认串口设备,并给予对应设备权限。",
        "deps_description_ros2": "ROS2需要安装micro-ROS进行串口通讯。分别依次运行以下指令配置micro-ROS并给予机械臂串口连接权限。",
        "create_workspace": "创建工作空间",
        "workspace_created": "工作空间创建成功",
        "workspace_creation_error": "创建工作空间时出错",
        "setup_ros2_description": "ROS2支持Ubuntu和Windows系统。请选择适合您系统的安装方式。建议使用Ubuntu 22.04 LTS,因为当前的包依赖对于ROS Humble及以上版本更加稳定。\n\nWindows系统的安装请参考外部资源。",
        "installation": "安装",
        "ros2_workspace_description": "选择ROS2工作空间路径并创建ROS2工作空间。这将创建必要的目录结构并设置环境变量。",
        "moveit_description_ros1": "使用MoveIt Setup Assistant配置机器人的运动规划功能。\n请运行以下命令启动配置助手。",
        "moveit_description_ros2": "使用MoveIt2 Setup Assistant配置机器人的运动规划功能。\n\n请运行以下命令启动配置助手。\n\n您必须使用ROS Humble或以上版本,因为MoveIt2仅支持Ubuntu >=20.04 LTS。",
        "copy": "复制",
        "copied_to_clipboard": "已复制到剪贴板",
        "view_tutorial": "查看配置教程",
        "final_step_description": "您现在拥有一个可用的ROS环境来控制机器人手臂。您可以启用机器人手臂的ROS模式并使用RVIZ测试您的机器人。以下是常用的命令:",
        "update_custom_firmware": "更新自定义固件",
        "no_ports_available": "没有可用的串口",
        "success": "成功",
        "update_success": "固件更新成功",
        "failed_fetch_firmware": "固件获取失败", 
        "error": "错误",
        "unknown_error": "未知错误",
        "tab_general": "通用",
        "tab_controller": "控制器",
        "tab_ros": "ROS",
        "tab_kinematics": "运动学",
        "tab_vision": "视觉",
        "kinematics_help": "## 术语\n\n## 正向运动学\n\n正向运动学用于计算机械臂末端执行器的位置和姿态。\n\n**使用方法：**\n- 调整关节角度滑块到期望位置\n\n## 逆向运动学\n\n逆向运动学用于计算关节空间中的角度，以达到指定的末端执行器/法兰姿态。\n\n## 雅可比矩阵\n\n雅可比矩阵是连接机器人关节速度与末端执行器（机器人手部或工具）速度的矩阵。它用于迭代方法中，通过计算移动末端执行器到特定方向所需的关节速度，来找到达到期望末端执行器姿态所需的关节角度。\n\n** 求解器选项：**\n1. Levenberg-Marquardt求解器\n\n2. 阻尼最小二乘求解器\n\n3. TRAC-IK求解器\n\n## 规划器组\n\n支持的规划器包括Direct、RRT和CHOMP。规划器的设计目的是生成包含一系列路径点的合理路径，同时避免路径上的碰撞。\n\n## 任务板：\n\n任务板适用于希望通过定义中间路径点来执行自动化任务的用户，例如码垛中的不间断任务。我们支持任务的导出和加载，并计划添加将任务转换为G代码的支持。",
        "vision_help": "# 视觉引导指南\n\n## 添加相机\n**1.** 点击右侧加号增加相机,最多两台。\n**2.** 相机可选分辨率,建议不超过1080p, 过大分辨率对检测速度有影响。\n\n## 标定\n在标定前需要选择Aruco标定板,选择合适的标定板格式并打印。\n\n具体步骤:\n**1.** 标定板选择。\n**2.** 手眼标定:选择眼在手或者眼在手外,对于眼在手外,需要额外进行标定板偏移设置。标定需要至少9个标本,每次请通过Kinematics页面调整机械臂姿态并发送,然后捕获当前标定板位姿。最后点击进行标定。\n**3.** 结果:请在结果栏查看transform矩阵,并通过3d plot检查相机位置是否正确,选择结果和实际最符合的标定方法。请保存该结果至本地。\n\n## 检测\n检测前需要进行localisation,通过运动末端执行器至相机中心点位置,检查相机至世界坐标系的误差,您可通过微调来补偿误差。\n**1.** 颜色检测:用户可通过选择当前帧中的颜色,或通过颜色板定义,并启动检测物体。\n**2.** 模板检测:首先裁剪当前帧以选择模板。Fast Fourier Transform模板检测可实现尺度和旋转不变性,您可以通过改变当前视图至correlation以查看FFT域的图片格式。当然,FFT检测对图片大小,绮变较为敏感,所以请使用较为小的分辨率确保检测速度和正确率。",
        "general_help": "## 软件用途？\n\n通过协议接口连接真实机械臂,软件可以为不同的机器人配置文件控制、规划和模拟多用途任务。\n\n## 支持的协议:\n\n1. 用于UART通信的串行协议。\n\n2. 用于闭环电机控制的CAN协议（开发中）\n\n3. 用户自定义协议以满足自身需求。\n\n## 机器人支持要求:\n\n1. MINIMA或带有URDF/Xacro/Mujoco的机械臂；\n\n2. 自由度小于7的机械臂。\n\n## 功能特点:\n\n1. 机器人配置:将机械臂描述为规划组。\n\n2. 控制:关节限位、关节空间运动和速度。\n\n3. 规划:具有运动学、避障、轨迹优化的组运动规划。\n\n4. 模拟:机器人运动与环境的交互，包括视觉形状、几何碰撞和自定义形状。\n\n5. ROS支持:ROS1和ROS2设置服务，包括系统设置、ROS快速设置、RViz和通信。\n\n6. 校准:PWM和微步进的初始关节角度校准。\n\n7. 轨迹优化:线性、梯形、S曲线、多项式（关节空间）和B样条及混合插值（笛卡尔空间）,具有速度、加速度、急动度和关节限制约束。\n\n8. 机器人编程语言:点到点、线性移动、圆弧移动、归零、延时和工具更换。\n\n9. 视觉应用:手眼标定和目标识别、模板匹配和物体检测。\n\n10. 工作空间分析:无自碰撞的可达区域。\n\n11. 固件更新:MINIMA的远程固件更新。\n\n12. LLM智能助手:机器人相关问答和基本软件操作。",
        "controller_help": "## 使用方法:\n通过机器人配置界面建立串行连接后,您可以通过滑块在关节空间控制机械臂,并校准机械臂到正确的归零位置。\n\n主要功能:\n\n1. 机器人运动的速度控制。\n\n2. 重播录制的机器人轨迹,具有暂停和重播次数功能。\n\n3. 为用户提供所有协议命令的访问权限和详细手册。\n\n## 附加功能:\n\n1. 自定义脚本生成以支持协议命令。\n\n2. 切换选项,通过由电位计驱动的小型控制器控制机械臂,用于远程操作（无官方套件,需要用户自行组装）",
        "firmware_help": "## 固件更新流程:\n\n1. 通过USB将机器人手臂连接到您的电脑。\n2. 按照屏幕上的说明操作,然后点击'更新固件'或'更新自定义固件'按钮。\n3. 更新过程中请勿断开手臂连接或关闭应用程序。\n\n## 常见问题:\n\n1. 问:固件更新通常需要多长时间？\n答:典型的更新需要10秒钟,具体取决于您的网络速度和固件大小。由于我们的远程服务器托管在GitHub上,建议使用VPN连接。\n\n2. 问:如果固件更新失败,我该怎么办？\n答:确保USB连接稳定,检查控制器板LED指示灯是否亮起,并确保您可以连接到Github。\n\n3. 问:新的固件版本多久发布一次？\n答:根据需要进行错误修复和新功能添加时发布更新。\n\n4. 问:是否有必要定期更新固件？\n答:虽然不总是必要,但我们建议保持固件最新,以确保最佳性能并获得最新功能。",
        "app_information": "应用信息",
        "contact_us": "联系我们",
        "website": "网站",
        "email": "邮箱",
        "item": "项目",
        "value": "值",
        "version": "版本",
        "release_date": "发布日期",
        "developer": "开发者",
        "dependencies": "依赖项",
        "platforms": "支持平台",
        "copyright_text": "NoMan Robotics 版权所有",
        "board_type": "开发板类型:  ESP32/Arduino",
        "library_type": "依赖库:    ",
        "command_info_title": "控制指令查询",
        "basic_control": "基础控制",
        "trajectory_recording": "轨迹录制",
        "trajectory_playback": "轨迹回放",
        "control_mode": "控制模式",
        "data_format": "数据格式",
        "joint_angle_array": "关节角度数组",
        "delay_time_desc": "输入格式\n- delay_time: 动作执行延迟(毫秒)",
        "record_feedback": "录制反馈",
        "min_pulse": "最小脉冲宽度",
        "max_pulse": "最大脉冲宽度",
        "frequency": "频率",
        "majordomo": "管家",
        "device": "设备",
        "send": "发送",
        "apply": "应用",
        "select_model": "选择模型:",
        "input_placeholder": "在此输入文本...",
        "speed": "速度:",
        "firmware_update": "固件更新",
        "upload": "刷写固件",
        "fetch_remote": "获取远程",
        "select_firmware": "选择固件:",
        "settings": "设置",
        "actuator_selection": "末端:",
        "check_version": "检查版本",
        "load_json_file": "加载JSON文件",
        "joint_angle_analysis": "关节角度分析",
        "time": "时间",
        "angle": "角度",
        "file_load_error": "文件加载错误",
        "tool_change_error": "工具更换错误",
        "robot_status": "机器人基座",
        "end_effector_offset": "末端中心偏移",
        "position": "位置(mm):",
        "orientation": "姿态(deg):",
        "scale_factor": "缩放因子:",
        "fixed_object": "固定对象（无物理效应）",
        "load_model": "加载模型",
        "shape_type": "形状类型:",
        "length": "长度:",
        "width": "宽度:",
        "height": "高度:",
        "size": "尺寸:",
        "radius": "半径:",
        "color": "颜色:",
        "alpha": "透明度:",
        "create": "创建",
        "set_base_pose": "设置基座位姿",
        "set_end_position": "设置末端位置",
        "start_simulation": "开始模拟",
        "stop_simulation": "停止模拟",
        "save_world": "保存世界",
        "load_world": "加载世界",
        "load_shapes": "加载形状",
        "collision_shapes": "碰撞形状",
        "visual_shapes": "视觉形状",
        "network_diagnosis": "网络诊断",
        "remote": "远程地址",
        "check": "检测",
        "calibration": "校准",
        "detection": "检测",
        "add_camera": "添加摄像头",
        "calibration_board": "标定板",
        "pose_sampling": "姿态采样",
        "result": "结果",
        "localisation": "定位",
        "detector": "检测器",
        "interaction": "交互",
        "control_with_vision": "视觉应用",
        "robot_control_language": "机器人控制语言",
        "workspace_analyzer": "工作空间分析器",
        "coordinate_system": "坐标系:",
        "joint_ranges": "关节范围",
        "analysis_settings": "分析设置",
        "sampling_resolution": "采样分辨率:",
        "alpha_value": "Alpha值:",
        "analyze_workspace": "分析工作空间",
        "ready_to_analyze": "准备分析...",
        "analysis_results": "分析结果",
        "workspace_volume": "工作空间体积:",
        "reachable_density": "可达点密度:",
        "gcode_controller": "G代码控制器",
        "rcl_editor": "RCL编辑器",
        "commands": "指令",
        "lookup": "指令检索",
        "load_gcode": "加载G代码",
        "save_gcode": "保存G代码",
        "text2gcode": "文本转G代码",
        "work_range": "工作范围",
        "preview": "预览",
        "compile": "编译",
        "simulate": "模拟",
        "status_ready": "状态:就绪",
        "status_paused": "状态:暂停",
        "status_running": "状态:运行中",
        "status_stopped": "状态:已停止",
        "status_complete": "状态:完成",
        "line_counter": "行",
        "clear_terminal": "清空终端",
        "gcode_lookup": "## 指令查询表\n────────────────────────────────────\n\n## 基本语法:\n- 每行一个指令\n- 分号(;)后添加注释\n- 坐标单位: 米(m)，角度单位: 度(°)\n\n## 快捷键:\n- Ctrl+F: 从当前机器人状态自动填充参数\n\n## 段落:\n@@-- header@@ 脚本开始段(可选)\n@@-- main@@ 主程序段\n@@-- footer@@ 脚本结束段\n\n## 解释:\n- 以下代码中，< >内为值内容，[ ]内为可选内容\n\n────────────────────────────────────\n\n## $$HOME$$ - 回到原点\n将机器人移动到预定义的零点位置\n语法: $$HOME$$;\n\n────────────────────────────────────\n\n## $$PTP$$ - 点到点运动\n以最短关节路径, 将末端执行器移动到指定的笛卡尔坐标位置\n语法: $$PTP$$ X=<x> Y=<y> Z=<z> [A=<a>] [B=<b>] [C=<c>];\n参数: X,Y,Z为位置坐标(米), A,B,C为旋转角度(度)\n- Ctrl+F: 自动填充当前目标位置和方向\n\n────────────────────────────────────\n\n## $$JTJ$$ - 关节空间运动\n以最短关节路径, 将选择的关节移动到指定的关节位置\n语法: $$JTJ$$ J1=<angle1> [J2=<angle2>] [J3=<angle3>] [J4=<angle4>] [J5=<angle5>] [J6=<angle6>] [J7=<angle7>] [vel{J1:<speed>%, J2:<speed>%, ...}];\n参数: J1,J2,J3,J4,J5,J6,J7为可选的关节参数(度), vel{}为可选速度限制(百分比)\n- Ctrl+F: 自动填充当前关节角度\n\n────────────────────────────────────\n\n## $$LIN$$ - 直线运动\n末端执行器沿直线路径移动到指定位置\n语法: $$LIN$$ X=<x> Y=<y> Z=<z> [A=<a>] [B=<b>] [C=<c>];\n参数: X,Y,Z为位置坐标(米), A,B,C为旋转角度(度)\n- Ctrl+F: 自动填充当前目标位置和方向\n\n────────────────────────────────────\n\n## $$CIRC$$ - 圆弧运动\n给定圆弧上的起点和终点和辅助点, 沿圆弧路径移动到目标位置\n语法: $$CIRC$$ X=<x> Y=<y> Z=<z> I=<i> J=<j> K=<k> [A=<a>] [B=<b>] [C=<c>];\n参数: X,Y,Z为目标位置(米), I,J,K为辅助点偏移(米), A,B,C为旋转角度(度)\n- Ctrl+F: 自动填充当前目标位置和方向，I=0 J=0 K=0\n\n────────────────────────────────────\n\n## $$VEL$$ - 速度设置\n设置各关节的速度限制\n语法: $$VEL$$ J1=<speed>% [J2=<speed>%] [J3=<speed>%] [J4=<speed>%] [J5=<speed>%] [J6=<speed>%] [J7=<speed>%];\n参数: J1,J2,J3,J4,J5,J6,J7为可选的关节速度参数(1-200%)\n\n────────────────────────────────────\n\n## $$DELAY$$ - 延迟\n在程序中插入暂停\n语法: $$DELAY$$ MS=<毫秒数>; 或 $$DELAY$$ S=<秒数>;\n参数: MS为毫秒数, S为秒数\n\n────────────────────────────────────\n\n## $$TOOL$$ - 工具切换\n切换末端执行器/工具状态\n语法: $$TOOL$$[<工具名称>] [IO<IO1>] [IO<IO2>];\n参数: 工具名称, IO1, IO2为工具的IO口(可选)\n注意: MINIMA 支持的工具为GRIPPER, PEN_HOLDER, VACUUM_PUMP, 其他工具需要自定义\n\n────────────────────────────────────\n\n## $$M280$$ - 夹爪控制\n控制夹爪状态(打开/关闭)\n语法: $$M280$$ state=<状态值>;\n参数: 状态值为夹爪状态(0=打开, 1=关闭)\n示例: $$M280$$ state=1; (关闭夹爪)",
        "ui_settings": "界面设置",
        "robot_settings": "机器人设置", 
        "advanced_settings": "高级设置",
        "language_settings": "语言设置",
        "interface_language": "界面语言:",
        "display_parameters": "显示参数",
        "calibration_settings": "校准设置",
        "speed_settings": "速度设置",
        "protocol_settings": "协议设置",
        "trajectory_optimiser": "轨迹优化器",
        "interpolation_settings": "插值设置",
        "ready": "准备就绪",
        "position_steps_kinematics": "位置步长（运动学）",
        "orientation_steps_kinematics": "方向步长（运动学）",
        "preview_point_radius": "预览点半径（RCL）",
        "preview_axis_length": "预览轴长度（RCL）",
        "serial_baud_rate": "串口波特率",
        "can_bitrate": "CAN比特率",
        "time_step_dt": "时间步长（dt）",
        "max_acceleration": "最大加速度",
        "max_jerk": "最大加加速度",
        "acceleration": "加速度",
        "jerk": "急动度",
        "trajectory_method": "轨迹方法",
        "interpolation_method": "插值方法",
        "degrees": "度",
        "tooltip_display_params": "控制位置步长、方向步长和预览可视化设置的显示和界面参数。",
        "tooltip_calibration": "独立校准每个关节。\n当关节在达到实际关节限位前就碰到物理限位时，应考虑减小范围。\n当关节不在正确的归零位置时，伺服电机的最大/最小脉宽会发生偏移。",
        "tooltip_speed": "控制各个关节的速度比例。",
        "tooltip_protocol": "配置串口波特率和CAN总线比特率用于机器人通信协议。",
        "tooltip_trajectory": "控制轨迹优化器参数。重启应用程序以应用更改。",
        "tooltip_interpolation": "控制路径规划的插值方法。\n\n线性：线性插值\n样条：三次B样条插值\n混合：贝塞尔插值",
        "file_type": "文件类型:",
        "file_path": "文件路径:",
        "tooltip_hand_eye_calibration": "手眼标定需要至少9个样本以获得准确结果。\n机械臂姿态需有显著差异以获取不同的视角。\n标定板图案应在相机视野范围内完全可见。",
        "license": "许可证",
        "license_status": "许可证状态",
        "software_activation": "软件激活",
        "activation_code": "激活码",
        "activate": "激活",
        "activating": "激活中...",
        "plan_description": "免费方案:\n- 使用与MINIMA相关的配置文件。\n\n许可方案:\n- 在MINIMA配置文件之外添加最多5个配置文件。",
        "license_type": "许可证类型:",
        "expiry_date": "过期日期:",
        "days_before_expiry": "距离过期:",
        "maximum_devices": "最大设备数:",
        "unlimited": "无限制",
        "expired": "已过期",
        "days": "天"
    },
    "日本語": {
        "robot_profile": "ロボットプロファイル",
        "type": "タイプ:",
        "name": "名前:",
        "joint_info": "機構情報",
        "controller": "コントローラー",
        "simulator": "シミュレーター",
        "firmware": "ファームウェア",
        "help": "ヘルプ",
        "language": "言語",
        "serial_connection": "シリアル接続",
        "arm_control": "アーム制御",
        "potentiometers_enabled": "ミニコントローラー",
        "potentiometers_disabled": "シリアル制御",
        "select_port": "ポートを選択",
        "status": "ステータス",
        "callback": "コールバック",
        "serial": "シリアル",
        "connect": "接続",
        "disconnect": "切断",
        "connected": "接続済み",
        "disconnected": "切断済み",
        "tool": "ツール",
        "loop_delay": "遅延（秒）",
        "execute": "実行",
        "record_once": "一度記録",
        "program": "プログラム",
        "start_recording": "録音開始",
        "stop_recording": "録音停止",
        "recording": "録音中...",
        "stopped_recording": "録音停止済み",
        "replay_trajectory": "軌道再生",
        "repeat": "繰り返し",
        "stop": "停止",
        "save": "保存",
        "load": "読み込み",
        "resume": "再開",
        "setting": "設定",
        "idle": "アイドル",
        "home": "ホーム",
        "calibrate_home": "ホームキャリブレーション",
        "signal_analyzer": "シグナルアナライザー",
        "generater": "スクリプト生成器",
        "reset": "リセット",
        "generate_script": "スクリプト生成",
        "board_caution": "現在、サーボモーターではPWMとサーボライブラリのみがサポートされています。他のカスタムボードはテストが必要です。",
        "joint_pins": "ジョイントピン",
        "gripper_pin": "グリッパーピン",
        "generate": "生成",
        "motor_count": "関節数",
        "enter_start_positions": "各サーボの開始位置を入力:",
        "min": "最小",
        "max": "最大",
        "angle_range": "角度範囲",
        "board": "開発ボード",
        "update_firmware": "ファームウェア更新",
        "parameters": "パラメータ",
        "arduino_parameters": "パラメータ",
        "arduino_model": "Arduino モデル",
        "baud_rate": "ボーレート",
        "flash_mode": "フラッシュモード",
        "flash_frequency": "フラッシュ周波数",
        "confirm": "確認",
        "update_custom_firmware": "カスタムファームウェア更新",
        "no_ports_available": "利用可能なポートがありません",
        "success": "成功",
        "update_success": "ファームウェア更新成功",
        "failed_fetch_firmware": "ファームウェア取得失敗",
        "error": "エラー",
        "unknown_error": "不明なエラーが発生しました",
        "ros": "ROS",
        "switch_to_ros": "ROSに切り替え",
        "setup_ros_description": "私たちのロボットはUbuntu 20.04 LTS, ROS Noeticで最初に開発されました。以下のリンクからクイックインストールガイドを見つけることができます。\n\n最も完全なサポートを得るために、noeticバージョン（Ubuntu 20.04 LTS）での開発をお勧めします。",
        "urdf_description": "ユニバーサルロボット記述フォーマット（URDF）は、ロボットの物理構造の記述です。\n\n1. リンクからURDFファイルをダウンロード\n2. ダウンロードしたファイルを解凍\n3. 解凍したファイルをワークスペースの/srcディレクトリに配置\n\n注意：ROS1とROS2のURDFフォーマットは異なり、互換性がありません！",
        "received_message": "受信メッセージ:",
        "ros_frame": "ROSフレーム",
        "ros_preparation": "ROSを有効にする前の準備",
        "enable_ros": "ROSを有効にする",
        "disable_ros": "ROSを無効にする",
        "enable_ros2": "ROS2を有効にする",
        "disable_ros2": "ROS2を無効にする",
        "system_check": "システムチェック",
        "ros_linux_only": "ROSはLinuxシステムでのみ利用可能です。",
        "system_not_linux": "システムはLinuxではありません",
        "checking_system": "システムを確認中...",
        "linux_version": "Linuxバージョン",
        "ros_version": "ROSバージョン",
        "error_checking_ros": "ROSバージョンの確認中にエラーが発生しました",
        "ros2_preparation": "ROS2を有効にする前の準備",
        "ros2_not_found": "ROS2インストールが見つかりません",
        "ros2_version": "ROS2バージョン",
        "step_1": "ステップ1: URDF記述をダウンロード",
        "step_2": "ステップ2: ROSを設定",
        "step_3": "ステップ3: ROSワークスペースを作成",
        "step_4": "ステップ4: MoveItを設定",
        "step_5": "ステップ5: 依存関係とシステム権限を設定",
        "step_6": "ステップ6: Rviz制御をテスト",
        "step_complete": "このステップを完了しました",
        "workspace_path": "ワークスペースパス",
        "workspace_description_ros1": "ワークスペースパスを選択し、ROSワークスペースを作成します。これにより、必要なディレクトリ構造が作成され、環境変数が設定されます。ROSのビルドコマンドは以下の通りです。",
        "workspace_description_ros2": "ワークスペースパスを選択し、ROS2ワークスペースを作成します。これにより、必要なディレクトリ構造が作成され、環境変数が設定されます。ROS2のビルドコマンドは以下の通りです。",
        "deps_description_ros1": "Rosserialでロボットアームを接続する前に、シリアルポートに権限を与える必要があります。デフォルトのシリアルポートは/dev/ttyUSB0です。以下のコマンドを使用して正しいポート番号を確認し、対応するデバイスに権限を与えてください。",
        "deps_description_ros2": "ROS2はシリアル通信のためにmicro-ROSをインストールする必要があります。以下のコマンドを順に実行してmicro-ROSを設定し、シリアルポートに権限を与えてください。",
        "create_workspace": "ワークスペースを作成",
        "workspace_created": "ワークスペースが正常に作成されました",
        "workspace_creation_error": "ワークスペースの作成中にエラーが発生しました",
        "setup_ros2_description": "ROS2はUbuntuとWindowsシステムをサポートしています。お使いのシステムに適したインストール方法を選択してください。Ubuntu 22.04 LTSを使用することをお勧めします。これは、ROS Humbleおよびそれ以降のバージョンのパッケージ依存関係がより安定しているためです。\n\nWindowsシステムのインストールについては、外部リソースを参照してください。",
        "installation": "インストール",
        "ros2_workspace_description": "ROS2ワークスペースパスを選択し、ROS2ワークスペースを作成します。これにより、必要なディレクトリ構造が作成され、環境変数が設定されます。",
        "moveit_description_ros1": "MoveIt Setup Assistantを使用して、ロボットのモーションプランニンググループを設定します。\n以下のコマンドを実行して設定アシスタントを開始してください。",
        "moveit_description_ros2": "MoveIt2 Setup Assistantを使用して、ロボットのモーションプランニンググループを設定します。\n\n以下のコマンドを実行して設定アシスタントを開始してください。\n\nROS Humble以上を使用する必要があります。これは、MSEがUbuntu >=20.04 LTSでのみサポートされているためです。",
        "copy": "コピー",
        "copied_to_clipboard": "クリップボードにコピーされました",
        "view_tutorial": "設定チュートリアルを表示",
        "final_step_description": "これで、ロボットアームを制御するための準備が整ったROS環境ができました。ロボットアームのROSモードを有効にし、RVIZを使用してロボットをテストできます。以下は一般的に使用されるコマンドです:",
        "serial_disconnect_warning": "更新するにはコントローラーのシリアルポートを切断してください。",
        "save_urdf_zip": "URDF ZIPを保存",
        "urdf_saved": "URDF ZIPファイルが正常に保存されました",
        "urdf_save_error": "URDF ZIPファイルの保存中にエラーが発生しました",
        "urdf_load_error": "URDFファイルの読み込み中にエラーが発生しました",
        "update_failed": "更新に失敗しました",
        "setup_ros": "ROSを設定",
        "kinematics": "運動学",
        "urdf_file": "URDFファイル:",
        "browse": "参照",
        "simulation": "シミュレーション",
        "forward_kinematics": "順運動学",
        "inverse_kinematics": "逆運動学",
        "calculate_end_position": "エンドポジションを計算",
        "calculate_joint_angles": "関節角度を計算",
        "send_to_robot": "送信",
        "joint": "関節",
        "end_position": "エンドポジション",
        "fk_result": "順運動学結果",
        "ik_result": "逆運動学結果",
        "forward_kinematics_result": "順運動学計算結果",
        "input_joint_angles": "関節角度を入力",
        "end_effector_position": "エンドエフェクタ位置",
        "end_effector_orientation": "エンドエフェクタ姿勢",
        "inverse_kinematics_complete": "逆運動学計算完了",
        "target_position": "目標位置",
        "actual_position": "実際の位置",
        "position_error": "位置誤差",
        "calculated_joint_angles": "計算された関節角度",
        "urdf_loaded_successfully": "URDFファイルが正常に読み込まれました",
        "failed_to_load_urdf": "URDFファイルの読み込みに失敗しました",
        "solver": "ソルバー",
        "planner": "プランナー",
        "solver_init": "ソルバー初期化",
        "lm_lambda": "ラムダ (λ)",
        "lm_epsilon": "イプシロン (ε)",
        "max_iterations": "最大反復回数",
        "dls_damping": "減衰係数",
        "dls_epsilon": "イプシロン (ε)",
        "sqp_mu": "ミュー (μ)",
        "sqp_epsilon": "イプシロン (ε)",
        "trac_ik_epsilon": "イプシロン (ε)",
        "self_collision_check": "自衝突検出",
        "pathpoints": "パスポイント",
        "urdf_file_not_found": "URDFファイルが見つかりません",
        "tab_general": "一般",
        "tab_controller": "コントローラー",
        "tab_kinematics": "運動学",
        "tab_vision": "ビジョン",
        "general_help": "## このソフトウェアの用途は？\n\nプロトコルインターフェースを通じて実際のロボットアームに接続し、さまざまなロボットプロファイルの多目的タスクを制御、計画、シミュレーションできます。\n\n## サポートされているプロトコル：\n\n1. UART通信用のシリアルプロトコル。\n\n2. 閉ループモーター制御用のCANプロトコル（開発中）\n\n3. 独自のニーズに対応するユーザー定義プロトコル。\n\n## ロボットサポートの要件：\n\n1. MINIMAまたはURDF/Xacro/Mujocoを持つロボットアーム；\n\n2. 自由度が7未満のロボットアーム。\n\n## 機能的な特徴：\n\n1. ロボットプロファイル：計画グループとしてのロボットアームの説明。\n\n2. 制御：関節制限、関節空間の動きと速度。\n\n3. 計画：運動学、衝突回避、軌道最適化を伴うグループの動作計画。\n\n4. シミュレーション：視覚的形状、幾何学的衝突、カスタム形状の下でのロボットの動きと環境の相互作用。\n\n5. ROSサポート：システムセットアップ、ROSクイックセットアップ、RVizおよび通信を含むROS1およびROS2セットアップサービス。\n\n6. キャリブレーション：PWMおよびマイクロステップの初期関節角度キャリブレーション。\n\n7. 軌道最適化：線形、台形、S曲線、多項式（関節空間）およびBスプラインとブレンド補間（デカルト空間）、速度、加速度、急動度および関節制限の制約付き。\n\n8. ロボットプログラミング言語：ポイントツーポイント、直線移動、円弧移動、ホーム、遅延およびツール変更。\n\n9. ビジョンアプリケーション：ハンドアイキャリブレーションとオブジェクト認識、テンプレートマッチングとオブジェクト検出。\n\n10. ワークスペース分析：自己衝突のない到達可能領域。\n\n11. ファームウェア更新：MINIMAのリモートからのファームウェア更新。\n\n12. LLMエージェント：ロボット関連のQ&Aと基本的なソフトウェア操作。",
        "controller_help": "## 使用方法：\nロボットプロファイルフレームを通じてシリアル接続を確立した後、スライダーを通じて関節空間でロボットアームを制御し、正しいホームポジションにロボットアームをキャリブレーションできます。\n\n主な機能：\n\n1. ロボット運動の速度制御。\n\n2. 一時停止とリプレイ回数機能付きで記録されたロボット軌道をリプレイ。\n\n3. 詳細マニュアル付きですべてのプロトコルコマンドへのユーザーアクセスを提供。\n\n## 追加機能：\n\n1. プロトコルコマンドをサポートするカスタムスクリプト生成。\n\n2. ポテンショメータで駆動されるミニコントローラーを通じてロボットアームを制御する切り替えオプション、遠隔操作目的（公式キットなし、ユーザーが組み立てる必要があります）",
        "kinematics_help": "## 用語\n\n## 順運動学\n\n順運動学は、ロボットアームのエンドエフェクタの位置と姿勢を計算するために使用されます。\n\n**使用方法：**\n- 関節角度スライダーを希望の位置に調整\n- \"エンドポジションを計算\"ボタンをクリック\n- システムはエンドエフェクタのX、Y、Z座標を表示します\n\n## 逆運動学\n\n逆運動学は、指定されたエンドエフェクタ/フランジポーズに到達するための関節空間での角度を計算するために使用されます。\n\n## ヤコビアン\n\nヤコビアンは、ロボットの関節の速度をエンドエフェクタ（ロボットのハンドまたはツール）の速度に関連付ける行列です。特定の方向にエンドエフェクタを移動させるために必要な関節速度を計算することにより、希望のエンドエフェクタポーズに到達するために必要な関節角度を見つけるための反復法で使用されます。\n\n**ソルバーオプション：**\n1. Levenberg-Marquardtソルバー\n\n2. 減衰最小二乗ソルバー\n\n3. TRAC-IKソルバー\n\n## プランナーグループ\n\nサポートされているプランナーはDirect、RRT、CHOMPです。プランナーの設計は、一連のウェイポイントを含む合理的な経路を生成し、同時に経路上の衝突を回避することです。\n\n## タスクボード：\n\nタスクボードは、パレタイジングなどの無停止タスクの中間ウェイポイントを定義して自動化タスクを実行したいユーザー向けです。タスクのエクスポートとロードをサポートし、タスクをGコードに変換するサポートを追加する予定です。",
        "vision_help": "## ビジョンガイダンス\n\n## カメラの追加\n**1.** 右側のプラスボタンをクリックしてカメラを追加します（最大2台）。\n**2.** カメラの解像度を選択できます。1080pを超えないことをお勧めします。高解像度は検出速度に影響します。\n\n## キャリブレーション\nキャリブレーション前にArucoキャリブレーションボードを選択し、適切なキャリブレーションボード形式を選択して印刷する必要があります。\n\n具体的な手順：\n**1.** キャリブレーションボードの選択。\n**2.** ハンドアイキャリブレーション：アイインハンドまたはアイトゥハンドを選択します。アイトゥハンドの場合、追加のキャリブレーションボードオフセット設定が必要です。キャリブレーションには少なくとも9つのサンプルが必要です。毎回Kinematicsページでロボットアームの姿勢を調整して送信し、現在のキャリブレーションボードの姿勢をキャプチャしてください。最後にキャリブレーションを実行をクリックします。\n**3.** 結果：結果セクションで変換行列を確認し、3d plotでカメラ位置の正確性を確認し、結果と実際が最も一致するキャリブレーション方法を選択してください。結果をローカルに保存してください。\n\n## 検出\n検出前にローカライゼーションが必要です。エンドエフェクタをカメラ中心位置に移動させ、カメラからワールド座標系への誤差を確認し、微調整で誤差を補償できます。\n**1.** 色検出：ユーザーは現在のフレームから色を選択するか、カラーパレットで定義して、オブジェクト検出を開始できます。\n**2.** テンプレート検出：まず現在のフレームをクロップしてテンプレートを選択します。高速フーリエ変換テンプレート検出はスケールと回転不変性を実現できます。現在のビューを相関に変更してFFTドメインの画像形式を表示できます。ただし、FFT検出は画像サイズと変形に敏感なので、検出速度と精度を確保するために小さな解像度を使用してください。",
        "firmware_help": "## ファームウェア更新プロセス：\n\n1. USBを介してロボットアームをコンピュータに接続します。\n2. 画面の指示に従い、「ファームウェア更新」または「カスタムファームウェア更新」ボタンを押します。\n3. 更新プロセス中は、アームを切断したりアプリを閉じたりしないでください。\n\n## よくある質問：\n\n1. Q: ファームウェア更新には通常どのくらい時間がかかりますか？\nA: 通常の更新には10秒かかりますが、インターネット速度とファームウェアのサイズによって異なります。リモートはGitHubでホストされているため、VPNで接続することをお勧めします。\n\n2. Q: ファームウェア更新が失敗した場合はどうすればよいですか？\nA: USB接続が安定していることを確認し、コントローラーボードのLEDが点灯していることを確認し、Githubに接続できることを確認してください。\n\n3. Q: 新しいファームウェアバージョンはどのくらいの頻度でリリースされますか？\nA: バグ修正と新機能のために必要に応じてリリースされます。\n\n4. Q: 定期的にファームウェアを更新する必要がありますか？\nA: 常に必要ではありませんが、最適なパフォーマンスを確保し、最新の機能にアクセスするためにファームウェアを最新の状態に保つことをお勧めします。",
        "app_information": "アプリ情報",
        "contact_us": "お問い合わせ",
        "website": "ウェブサイト",
        "email": "メール",
        "item": "項目",
        "value": "値",
        "version": "バージョン",
        "release_date": "リリース日",
        "developer": "開発者",
        "dependencies": "依存関係",
        "platforms": "プラットフォーム",
        "copyright_text": "NoMan Robotics 全著作権所有",
        "board_type": "ボードタイプ: ESP32/Arduino",
        "library_type": "ライブラリ:",
        "command_info_title": "制御指令の確認",
        "basic_control": "基本制御",
        "trajectory_recording": "軌道記録",
        "trajectory_playback": "軌道再生",
        "control_mode": "制御モード",
        "data_format": "データ形式",
        "joint_angle_array": "関節角度配列",
        "delay_time_desc": "入力フォーマット\n- delay_time: 動作実行遅延（ミリ秒）",
        "record_feedback": "記録フィードバック",
        "min_pulse": "最小パルス幅",
        "max_pulse": "最大パルス幅",
        "frequency": "周波数",
        "majordomo": "執事",
        "device": "デバイス",
        "send": "送信",
        "apply": "適用",
        "select_model": "モデルを選択:",
        "input_placeholder": "ここにテキストを入力...",
        "speed": "速度:",
        "firmware_update": "ファームウェア更新",
        "upload": "ファームウェア書き込み",
        "fetch_remote": "リモート取得",
        "select_firmware": "ファームウェア選択:",
        "settings": "設定",
        "actuator_selection": "末端:",
        "check_version": "バージョンを確認",
        "load_json_file": "JSONファイルを読み込む",
        "joint_angle_analysis": "関節角度分析",
        "time": "時間",
        "angle": "角度",
        "file_load_error": "ファイル読み込みエラー",
        "tool_change_error": "ツール変更エラー",
        "robot_status": "ロボットベース",
        "end_effector_offset": "エンドエフェクタオフセット",
        "position": "位置(mm):",
        "orientation": "姿勢(deg):",
        "scale_factor": "スケールファクタ:",
        "fixed_object": "固定オブジェクト（物理効果なし）",
        "load_model": "モデルを読込",
        "shape_type": "形状タイプ:",
        "length": "長さ:",
        "width": "幅:",
        "height": "高さ:",
        "size": "サイズ:",
        "radius": "半径:",
        "color": "色:",
        "alpha": "透明度:",
        "create": "作成",
        "set_base_pose": "ベースポーズを設定",
        "set_end_position": "エンド位置を設定",
        "start_simulation": "シミュレーション開始",
        "stop_simulation": "シミュレーション停止",
        "save_world": "ワールドを保存",
        "load_world": "ワールドを読込",
        "load_shapes": "形状を読込",
        "collision_shapes": "衝突形状",
        "visual_shapes": "視覚形状",
        "network_diagnosis": "ネットワーク診断",
        "remote": "リモート",
        "check": "チェック",
        "calibration": "キャリブレーション",
        "detection": "検出",
        "add_camera": "カメラを追加",
        "calibration_board": "キャリブレーションボード",
        "pose_sampling": "ポーズサンプリング",
        "result": "結果",
        "localisation": "位置検出",
        "detector": "検出器",
        "interaction": "インタラクション",
        "control_with_vision": "ビジョン",
        "robot_control_language": "ロボット制御言語",
        "workspace_analyzer": "作業空間",
        "coordinate_system": "座標系:",
        "joint_ranges": "関節範囲",
        "analysis_settings": "解析設定",
        "sampling_resolution": "サンプリング解像度:",
        "alpha_value": "Alpha値:",
        "analyze_workspace": "ワークスペース解析",
        "ready_to_analyze": "解析準備完了...",
        "analysis_results": "解析結果",
        "workspace_volume": "ワークスペース体積:",
        "reachable_density": "到達可能密度:",
        "gcode_controller": "Gコードコントローラー",
        "rcl_editor": "RCLエディター",
        "commands": "コマンド",
        "lookup": "命令検索",
        "load_gcode": "Gコード読込",
        "save_gcode": "Gコード保存",
        "text2gcode": "テキスト変換",
        "work_range": "作業範囲",
        "preview": "プレビュー",
        "compile": "コンパイル",
        "simulate": "シミュレート",
        "status_ready": "ステータス:準備完了",
        "status_paused": "ステータス:一時停止",
        "status_running": "ステータス:実行中",
        "status_stopped": "ステータス:停止",
        "status_complete": "ステータス:完了",
        "line_counter": "行",
        "clear_terminal": "ターミナルクリア",
        "gcode_lookup": "## コマンド検索表\n────────────────────────────────────\n\n## 基本構文:\n- 1行に1つのコマンド\n- セミコロン(;)の後にコメントを追加\n- 座標単位: メートル(m)、角度単位: 度(°)\n\n## ショートカット:\n- Ctrl+F: 現在のロボット状態からパラメータを自動入力\n\n## セクション:\n@@-- header@@ スクリプト開始セクション(オプション)\n@@-- main@@ メインプログラムセクション\n@@-- footer@@ スクリプト終了セクション\n\n## 説明:\n- 以下のコードで、< >内は値の内容、[ ]内はオプションの内容\n\n────────────────────────────────────\n\n## $$HOME$$ - 原点復帰\nロボットを事前定義されたゼロ位置に移動\n構文: $$HOME$$;\n\n────────────────────────────────────\n\n## $$PTP$$ - ポイントツーポイント運動\n最短関節パスでエンドエフェクタを指定されたデカルト座標位置に移動\n構文: $$PTP$$ X=<x> Y=<y> Z=<z> [A=<a>] [B=<b>] [C=<c>];\nパラメータ: X,Y,Zは位置座標(メートル)、A,B,Cは回転角度(度)\n- Ctrl+F: 現在の目標位置と姿勢を自動入力\n\n────────────────────────────────────\n\n## $$JTJ$$ - 関節空間運動\n最短関節パスで選択された関節を指定された関節位置に移動\n構文: $$JTJ$$ J1=<angle1> [J2=<angle2>] [J3=<angle3>] [J4=<angle4>] [J5=<angle5>] [J6=<angle6>] [J7=<angle7>] [vel{J1:<speed>%, J2:<speed>%, ...}];\nパラメータ: J1,J2,J3,J4,J5,J6,J7はオプションの関節パラメータ(度)、vel{}はオプションの速度制限(パーセンテージ)\n- Ctrl+F: 現在の関節角度を自動入力\n\n────────────────────────────────────\n\n## $$LIN$$ - 直線運動\nエンドエフェクタを直線パスで指定位置に移動\n構文: $$LIN$$ X=<x> Y=<y> Z=<z> [A=<a>] [B=<b>] [C=<c>];\nパラメータ: X,Y,Zは位置座標(メートル)、A,B,Cは回転角度(度)\n- Ctrl+F: 現在の目標位置と姿勢を自動入力\n\n────────────────────────────────────\n\n## $$CIRC$$ - 円弧運動\n円弧上の開始点、終了点、補助点を与えて、円弧パスで目標位置に移動\n構文: $$CIRC$$ X=<x> Y=<y> Z=<z> I=<i> J=<j> K=<k> [A=<a>] [B=<b>] [C=<c>];\nパラメータ: X,Y,Zは目標位置(メートル)、I,J,Kは補助点オフセット(メートル)、A,B,Cは回転角度(度)\n- Ctrl+F: 現在の目標位置と姿勢、I=0 J=0 K=0を自動入力\n\n────────────────────────────────────\n\n## $$VEL$$ - 速度設定\n各関節の速度制限を設定\n構文: $$VEL$$ J1=<speed>% [J2=<speed>%] [J3=<speed>%] [J4=<speed>%] [J5=<speed>%] [J6=<speed>%] [J7=<speed>%];\nパラメータ: J1,J2,J3,J4,J5,J6,J7はオプションの関節速度パラメータ(1-200%)\n\n────────────────────────────────────\n\n## $$DELAY$$ - 遅延\nプログラムに一時停止を挿入\n構文: $$DELAY$$ MS=<ミリ秒>; または $$DELAY$$ S=<秒>;\nパラメータ: MSはミリ秒、Sは秒\n\n────────────────────────────────────\n\n## $$TOOL$$ - ツール切替\nエンドエフェクタ/ツール状態を切り替え\n構文: $$TOOL$$[<ツール名>] [IO<IO1>] [IO<IO2>];\nパラメータ: ツール名、IO1、IO2はツールのIOポート(オプション)\n注意: MINIMAはGRIPPER、PEN_HOLDER、VACUUM_PUMPをサポート、その他のツールはカスタマイズが必要\n\n────────────────────────────────────\n\n## $$M280$$ - グリッパー制御\nグリッパー状態を制御(開/閉)\n構文: $$M280$$ state=<状態値>;\nパラメータ: 状態値はグリッパー状態(0=開、1=閉)\n例: $$M280$$ state=1; (グリッパーを閉じる)",
        "ui_settings": "UI設定",
        "robot_settings": "ロボット設定", 
        "advanced_settings": "高度な設定",
        "language_settings": "言語設定",
        "interface_language": "インターフェース言語:",
        "display_parameters": "表示パラメータ",
        "calibration_settings": "キャリブレーション設定",
        "speed_settings": "速度設定",
        "protocol_settings": "プロトコル設定",
        "trajectory_optimiser": "軌道オプティマイザー",
        "interpolation_settings": "補間設定",
        "ready": "準備完了",
        "position_steps_kinematics": "位置ステップ（運動学）",
        "orientation_steps_kinematics": "姿勢ステップ（運動学）",
        "preview_point_radius": "プレビューポイント半径（RCL）",
        "preview_axis_length": "プレビュー軸長（RCL）",
        "serial_baud_rate": "シリアルボーレート",
        "can_bitrate": "CANビットレート",
        "time_step_dt": "時間ステップ（dt）",
        "max_acceleration": "最大加速度",
        "max_jerk": "最大ジャーク",
        "acceleration": "加速度",
        "jerk": "ジャーク",
        "trajectory_method": "軌道方法",
        "interpolation_method": "補間方法",
        "degrees": "度",
        "tooltip_display_params": "位置ステップ、姿勢ステップ、プレビュー可視化設定の表示およびインターフェースパラメータを制御します。",
        "tooltip_calibration": "各関節を独立してキャリブレーションします。\n関節が実際の関節限界に達する前に物理的限界に当たる場合は、範囲を減らすことを検討してください。\n関節が正しいホーム位置にない場合、サーボモーターの最大/最小パルス幅がシフトします。",
        "tooltip_speed": "各関節の速度スケールを制御します。",
        "tooltip_protocol": "ロボット通信プロトコル用のシリアルポートボーレートとCANバスビットレートを設定します。",
        "tooltip_trajectory": "軌道オプティマイザーパラメータを制御します。変更を適用するにはアプリケーションを再起動してください。",
        "tooltip_interpolation": "パスプランニングの補間方法を制御します。\n\n線形：線形補間\nスプライン：3次Bスプライン補間\nブレンド：ベジェ補間",
        "file_type": "ファイルタイプ:",
        "file_path": "ファイルパス:",
        "tooltip_hand_eye_calibration": "ハンドアイキャリブレーションには正確な結果を得るために少なくとも9つのサンプルが必要です。\nロボットの姿勢は異なる視点を得るために大きく異なる必要があります。\nキャリブレーションボードのパターンはカメラの視野内で完全に見える必要があります。",
        "license": "ライセンス",
        "license_status": "ライセンス状態",
        "software_activation": "ソフトウェアアクティベーション",
        "activation_code": "アクティベーションコード",
        "activate": "アクティベート",
        "activating": "アクティベーション中...",
        "plan_description": "無料プラン:\n- MINIMAに関連するプロファイルのみを使用。\n\nライセンスプラン:\n- MINIMAプロファイルに加えて最大5つのプロファイルを追加。",
        "license_type": "ライセンスタイプ:",
        "expiry_date": "有効期限:",
        "days_before_expiry": "有効期限まで:",
        "maximum_devices": "最大デバイス数:",
        "unlimited": "無制限",
        "expired": "期限切れ",
        "days": "日"
    }
}
